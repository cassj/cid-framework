AWSTemplateFormatVersion: '2010-09-09'
Description: Organization data collections.
Parameters:
  ManagementRoleName:
    Type: String
    Description: The name of the IAM role that will be deployed in the management account which can retrieve AWS Organization data. KEEP THE SAME AS WHAT IS DEPLOYED INTO MANAGEMENT ACCOUNT
  ManagementAccountID:
    Type: String
    AllowedPattern: ([a-z0-9\-, ]*?$)
    Description: "(Ex: 123456789,098654321,789054312) List of Payer IDs you wish to collect data for. Can just be one Accounts"
  ResourcePrefix:
    Type: String
    Description: This prefix will be placed in front of all roles created. Note you may wish to add a dash at the end to make more readable
Outputs:
  LambdaFunctionName:
    Value: !Ref LambdaFunction
  LambdaFunctionARN:
    Description: Lambda function ARN
    Value: !GetAtt LambdaFunction.Arn
    Export:
      Name: !Sub ${ResourcePrefix}AccountCollectorLambdaARN
Resources:
  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ResourcePrefix}account-collector-LambdaRole"
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
        Version: 2012-10-17
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Path: /
      Policies:
        - PolicyName: "AssumeManagementRole"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action: "sts:AssumeRole"
                Resource: !Sub "arn:aws:iam::*:role/${ManagementRoleName}" # Need to assume a Read role in all Management Accounts
        - PolicyName: "CloudWatch"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                  - "logs:DescribeLogStreams"
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/*"
        - PolicyName: "SSM"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - "ssm:GetParameter"
                Resource: !Sub "arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/cid/${ResourcePrefix}*"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28 # Resource found with an explicit name, this disallows updates that require replacement of this resource
            reason: "Need explicit name to identify role actions"

  LambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ResourcePrefix}account-collector-Lambda'
      Description: "Lambda function to retrieve the account list"
      Runtime: python3.10
      Architectures: [x86_64]
      Code:
          ZipFile: |
            import os
            import json
            import logging
            from functools import partial

            import boto3

            ROLE_NAME = os.environ['ROLE_NAME']
            RESOURCE_PREFIX = os.environ['RESOURCE_PREFIX']
            MANAGEMENT_ACCOUNT_IDS = os.environ['MANAGEMENT_ACCOUNT_IDS']

            logger = logging.getLogger(__name__)
            logger.setLevel(getattr(logging, os.environ.get('LOG_LEVEL', 'INFO').upper(), logging.INFO))

            def lambda_handler(event, context): #pylint: disable=unused-argument
                logger.info(f"Incoming event: {event}")
                functions = { # keep keys same as boto3 services
                    'linked': iterate_linked_accounts,
                    'payers': partial(iterate_admins_accounts, None),
                    'organizations': partial(iterate_admins_accounts, 'organizations'),
                    'compute-optimizer': partial(iterate_admins_accounts, 'compute-optimizer'),
                    'backup': partial(iterate_admins_accounts, 'backup'),
                }
                account_type = event.get("Type", '').lower()
                if account_type not in functions:
                    raise Exception(f"Lambda event must have 'Type' parameter with value = ({list(functions.keys())})") #pylint: disable=broad-exception-raised
                account_iterator = functions[account_type]
                accounts = list(account_iterator())
                if not accounts:
                    raise Exception('No accounts found. Check the log.') #pylint: disable=broad-exception-raised
                return {'statusCode': 200, 'accountList': accounts}

            def get_all_payers():
                for payer_id in MANAGEMENT_ACCOUNT_IDS.split(','):
                    yield payer_id.strip()

            def iterate_admins_accounts(service=None):
                ssm = boto3.client('ssm')
                for payer_id in get_all_payers():
                    account_id = payer_id # default
                    if service:
                        ssm_key = f'/cid/{RESOURCE_PREFIX}config/delegated-admin/{service}/{payer_id}'
                        try:
                            account_id = ssm.get_parameter(Name=ssm_key)['Parameter']['Value']
                        except ssm.exceptions.ParameterNotFound:
                            logger.warning(f'Not found ssm parameter {ssm_key}. Will use Management Account Id {payer_id}')
                    yield {"account": json.dumps({'account_id': account_id, 'account_name': '', 'payer_id': payer_id})}

            def iterate_linked_accounts():
                for org_account_data in iterate_admins_accounts('organizations'):
                    org_account = json.loads(org_account_data['account'])
                    try:
                        organizations = get_client_with_role(service="organizations", account_id=org_account['account_id'], region="us-east-1") #MUST be us-east-1
                        for account in organizations.get_paginator("list_accounts").paginate().search("Accounts[?Status=='ACTIVE']"):
                            yield {
                                "account": json.dumps({
                                    'account_id': account.get('Id'),
                                    'account_name': account.get('Name'),
                                    'payer_id': org_account['payer_id'],
                                })
                            }
                    except Exception as exc: #pylint: disable=broad-exception-caught
                        logger.error(f'{payer_id}: {exc}')

            def dummy_iterate_linked_accounts():
                # use this function if you have no access to payer or delegated admin at all
                hardcoded_accounts = [
                    {'account_id': '111222333444', 'account_name': 'replaceme', 'payer_id': '666777888999'},
                    {'account_id': '555666777888', 'account_name': 'replaceme', 'payer_id': '666777888999'},
                ]
                for account_data in hardcoded_accounts:
                    yield {"account": json.dumps(account_data)}

            def get_client_with_role(account_id, service, region):
                credentials = boto3.client('sts').assume_role(
                    RoleArn=f"arn:aws:iam::{account_id}:role/{ROLE_NAME}",
                    RoleSessionName="data_collection"
                )['Credentials']
                return boto3.client(
                    service,
                    region_name=region,
                    aws_access_key_id=credentials['AccessKeyId'],
                    aws_secret_access_key=credentials['SecretAccessKey'],
                    aws_session_token=credentials['SessionToken'],
                )

      Handler: 'index.lambda_handler'
      MemorySize: 2688
      Timeout: 600
      Role: !GetAtt LambdaRole.Arn
      Environment:
        Variables:
          ROLE_NAME: !Ref ManagementRoleName
          MANAGEMENT_ACCOUNT_IDS: !Ref ManagementAccountID
          RESOURCE_PREFIX: !Ref ResourcePrefix
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89 # Lambda functions should be deployed inside a VPC
            reason: "No need for VPC in this case"
          - id: W92 #  Lambda functions should define ReservedConcurrentExecutions to reserve simultaneous executions
            reason: "No need for simultaneous execution"